<!DOCTYPE html>
<html>
    <head>
        <title>OII Network Visualisation Example</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width,height=device-height,initial-scale=1,user-scalable=no" />
        <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    </head>
    <body>
        <div id="divContainer" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%;"></div>

        <script type="text/javascript" src="js/jquery/jquery.min.js"></script>

        <script type="text/javascript" src="js/three.min.js"></script>
        <script type="text/javascript" src="js/OrbitControls.js"></script>
        <script type="text/javascript" src="js/stats.min.js"></script>
        
        <script type="text/javascript">
            $(document).ready(function () {
                var container = document.getElementById("divContainer");
                var $container = $(container);

                var width = $container.width(), height = $container.height();

                $.getJSON("data.json", function (data) {
                    var scene = new THREE.Scene();

                    var camera = new THREE.PerspectiveCamera(75, width / height, 1, 1000);
                    camera.position.z = 500;

                    var renderer = new THREE.WebGLRenderer({ antialias: false });
                    renderer.setPixelRatio(window.devicePixelRatio);
                    renderer.setSize(width, height);

                    container.appendChild(renderer.domElement);
                    
                    var controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableZoom = true;

                    var nodes = [], nodeGroups = [], meshes = [];
                    var noMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    
                    var nodeGeo = new THREE.SphereBufferGeometry(10, 12, 8);

                    $.each(data.nodes, function (i, n) {
                        //if (i > 100) return;

                        n.z = Math.sqrt(75000 - (n.x * n.x + n.y * n.y)) * (n.id % 2 == 0 ? 1 : -1);
                        n.size = Math.floor(n.size * 10);
                        
                        nodes[n.id] = n;

                        var nodeGroup = nodeGroups[n.attributes["Modularity Class"]];
                        
                        if (nodeGroup == null) {
                            nodeGroup = { material: new THREE.MeshBasicMaterial({ color: n.color }), geo: new THREE.Geometry() };
                            nodeGroups[n.attributes["Modularity Class"]] = nodeGroup;
                        }

                        var mesh = meshes[n.size];
                        
                        if (mesh == null) {
                            mesh = new THREE.Mesh(new THREE.SphereGeometry(n.size / 10, 12, 8), noMaterial);
                            mesh.matrixAutoUpdate = false;
                            meshes[n.size] = mesh;
                        }

                        mesh.position.x = n.x;
                        mesh.position.y = n.y;
                        mesh.position.z = n.z;

                        mesh.updateMatrix();
                        nodeGroup.geo.merge(mesh.geometry, mesh.matrix);
                    });
                    
                    $.each(nodeGroups, function (i, g) {
                        if (g == null) return;
                        scene.add(new THREE.Mesh(g.geo, g.material));
                    });

                    var lineMaterial = new THREE.LineBasicMaterial({ color: 0x555555 });
                    var lineGeo = new THREE.Geometry();

                    $.each(data.edges, function (i, e) {
                        var source = nodes[e.source], target = nodes[e.target];
                        if (source == null || target == null) return;

                        lineGeo.vertices.push(new THREE.Vector3(source.x, source.y, source.z));
                        lineGeo.vertices.push(new THREE.Vector3(target.x, target.y, target.z));
                    });
                    
                    var line = new THREE.Line(lineGeo, lineMaterial);
                    scene.add(line);
                    
                    var stats = new Stats();
                    container.appendChild(stats.dom);

                    function animate() {
                        requestAnimationFrame(animate);
                        controls.update();
                        render();
                        stats.update();
                    }

                    function render() {
                        renderer.render(scene, camera);
                    }

                    animate();
                });
            });
        </script>
    </body>
</html>
